[
    {
        "title": "OTP Application Structure",
        "content": "## OTP Application Structure\n\nErlang/OTP applications follow a standard structure:\n\n### Application Behavior\n```erlang\n-module(my_app).\n-behaviour(application).\n\n-export([start/2, stop/1]).\n\nstart(_StartType, _StartArgs) ->\n    my_app_sup:start_link().\n\nstop(_State) ->\n    ok.\n```\n\n### Supervisor Pattern\n```erlang\n-module(my_app_sup).\n-behaviour(supervisor).\n\n-export([start_link/0, init/1]).\n\nstart_link() ->\n    supervisor:start_link({local, ?MODULE}, ?MODULE, []).\n\ninit([]) ->\n    SupFlags = #{strategy => one_for_one,\n                 intensity => 5,\n                 period => 10},\n    ChildSpecs = [\n        #{id => worker1,\n          start => {worker1, start_link, []},\n          restart => permanent,\n          shutdown => 5000,\n          type => worker}\n    ],\n    {ok, {SupFlags, ChildSpecs}}.\n```\n\n### Key Principles\n1. Use behaviors (application, supervisor, gen_server, gen_statem)\n2. Let it crash - use supervisors for fault tolerance\n3. Keep supervision trees balanced\n4. Use permanent restart strategy for critical workers\n5. Use temporary for one-off tasks",
        "category": "coding-patterns",
        "language": "erlang",
        "priority": 100,
        "tags": [
            "otp",
            "application",
            "supervisor",
            "architecture"
        ]
    },
    {
        "title": "Error Handling with Tuples",
        "content": "## Erlang Error Handling Patterns\n\n### Return Tuples\nALWAYS use tagged tuples for function returns:\n\n```erlang\n%% SUCCESS CASE\n{ok, Result}\n{ok, Data, Metadata}\n\n%% ERROR CASES\n{error, Reason}\n{error, Code, Details}\n```\n\n### Pattern Matching\n```erlang\ncase do_something() of\n    {ok, Result} ->\n        process_result(Result);\n    {error, not_found} ->\n        handle_not_found();\n    {error, Reason} ->\n        handle_error(Reason)\nend.\n```\n\n### Never Use Exceptions for Flow Control\n❌ **WRONG:**\n```erlang\ntry\n    Result = risky_operation(),\n    {ok, Result}\ncatch\n    _:_ -> {error, failed}\nend.\n```\n\n✅ **CORRECT:**\n```erlang\ncase risky_operation() of\n    {ok, Result} -> {ok, Result};\n    {error, Reason} -> {error, Reason}\nend.\n```\n\n### Use try/catch Only for External Calls\nOnly use try/catch when calling code you don't control:\n\n```erlang\ntry\n    ExternalLib:call(Args)\ncatch\n    error:Reason:Stacktrace ->\n        logger:error(\"External call failed: ~p~n~p\", [Reason, Stacktrace]),\n        {error, external_failure}\nend.\n```",
        "category": "coding-patterns",
        "language": "erlang",
        "priority": 99,
        "tags": [
            "error-handling",
            "tuples",
            "pattern-matching"
        ]
    },
    {
        "title": "Gen Server Pattern",
        "content": "## GenServer Implementation Pattern\n\n### Basic Structure\n```erlang\n-module(my_server).\n-behaviour(gen_server).\n\n%% API\n-export([start_link/0, do_something/1]).\n\n%% gen_server callbacks\n-export([init/1, handle_call/3, handle_cast/2, handle_info/2,\n         terminate/2, code_change/3]).\n\n-record(state, {\n    data :: term(),\n    counter = 0 :: non_neg_integer()\n}).\n\n%%%===================================================================\n%%% API\n%%%===================================================================\n\nstart_link() ->\n    gen_server:start_link({local, ?MODULE}, ?MODULE, [], []).\n\ndo_something(Arg) ->\n    gen_server:call(?MODULE, {do_something, Arg}).\n\n%%%===================================================================\n%%% gen_server callbacks\n%%%===================================================================\n\ninit([]) ->\n    {ok, #state{}}.\n\nhandle_call({do_something, Arg}, _From, State) ->\n    case process_arg(Arg) of\n        {ok, Result} ->\n            {reply, {ok, Result}, State#state{counter = State#state.counter + 1}};\n        {error, Reason} ->\n            {reply, {error, Reason}, State}\n    end;\nhandle_call(_Request, _From, State) ->\n    {reply, {error, unknown_call}, State}.\n\nhandle_cast(_Msg, State) ->\n    {noreply, State}.\n\nhandle_info(_Info, State) ->\n    {noreply, State}.\n\nterminate(_Reason, _State) ->\n    ok.\n\ncode_change(_OldVsn, State, _Extra) ->\n    {ok, State}.\n\n%%%===================================================================\n%%% Internal functions\n%%%===================================================================\n\nprocess_arg(Arg) ->\n    %% Implementation\n    {ok, processed}.\n```\n\n### Best Practices\n1. Always handle unknown messages\n2. Use records for state\n3. Keep handle_call clauses focused\n4. Return proper tuples: {reply, Reply, NewState} or {noreply, NewState}\n5. Use timeouts for long operations\n6. Implement terminate/2 for cleanup",
        "category": "coding-patterns",
        "language": "erlang",
        "priority": 98,
        "tags": [
            "gen_server",
            "behavior",
            "state-management"
        ]
    },
    {
        "title": "Type Specifications",
        "content": "## Erlang Type Specifications\n\nALWAYS add type specs to exported functions:\n\n### Basic Specs\n```erlang\n-spec function_name(Arg1Type, Arg2Type) -> ReturnType.\nfunction_name(Arg1, Arg2) ->\n    implementation.\n```\n\n### Common Patterns\n```erlang\n%% Simple types\n-spec get_user(UserId :: integer()) -> {ok, map()} | {error, atom()}.\n\n%% Multiple clauses\n-spec format(atom() | binary()) -> binary().\n\n%% Records\n-spec process_request(#request{}) -> {ok, #response{}} | {error, term()}.\n\n%% Lists\n-spec filter_items([Item :: map()]) -> [Item :: map()].\n\n%% With constraints\n-spec merge_maps(Map1, Map2) -> MergedMap when\n    Map1 :: map(),\n    Map2 :: map(),\n    MergedMap :: map().\n```\n\n### Type Definitions\n```erlang\n-type user_id() :: pos_integer().\n-type username() :: binary().\n-type error_reason() :: atom() | {atom(), term()}.\n\n-type user() :: #{\n    id := user_id(),\n    username := username(),\n    email => binary()\n}.\n\n-spec create_user(username(), binary()) -> {ok, user()} | {error, error_reason()}.\n```\n\n### Dialyzer\nAlways run dialyzer before committing:\n```bash\nmake dialyzer\n# or\nrebar3 dialyzer\n```",
        "category": "coding-patterns",
        "language": "erlang",
        "priority": 97,
        "tags": [
            "types",
            "specs",
            "dialyzer"
        ]
    },
    {
        "title": "Database Migration Ordering",
        "content": "## Database Migration Order for Erlang Projects\n\n### CRITICAL: Always Follow This Order\n\n1. **Database Schema Changes First**\n   - Add new columns/tables\n   - Update migrations\n   - Run migrations in development\n   - Verify schema changes\n\n2. **Code Changes Second**\n   - Update Erlang records\n   - Update functions using the schema\n   - Add tests\n\n3. **Deploy in Correct Sequence**\n   - Deploy schema migrations\n   - Wait for completion\n   - Then deploy code changes\n\n### Adding a Column\n```sql\n-- Migration: 20240101_add_user_status.sql\nALTER TABLE users ADD COLUMN status VARCHAR(20) DEFAULT 'active';\n```\n\n```erlang\n%% BEFORE code deployment, ensure migration is run\n-record(user, {\n    id :: integer(),\n    username :: binary(),\n    status = <<\"active\">> :: binary()  % New field with default\n}).\n```\n\n### Backward Compatibility\n- Always add new fields with defaults\n- Don't remove fields in same release\n- Deprecate first, remove later\n- Handle both old and new schemas during transition\n\n### Example Safe Migration\n```erlang\n%% Phase 1: Add optional field\nget_user(Id) ->\n    case db:query(\"SELECT * FROM users WHERE id = $1\", [Id]) of\n        {ok, Rows} ->\n            User = parse_user(Rows),\n            %% Status might not exist yet\n            Status = maps:get(status, User, <<\"active\">>),\n            {ok, User#{status => Status}};\n        {error, Reason} ->\n            {error, Reason}\n    end.\n```",
        "category": "coding-patterns",
        "language": "erlang",
        "priority": 96,
        "tags": [
            "database",
            "migrations",
            "deployment",
            "critical"
        ]
    },
    {
        "title": "Testing Patterns",
        "content": "## Erlang Testing Patterns\n\n### EUnit Tests\n```erlang\n-module(my_module_tests).\n-include_lib(\"eunit/include/eunit.hrl\").\n\n%% Test functions end with _test\nsimple_test() ->\n    ?assertEqual(5, my_module:add(2, 3)).\n\n%% Test generators end with _test_\ncomplex_test_() ->\n    [\n        ?_assertEqual(true, my_module:is_valid(data)),\n        ?_assertMatch({ok, _}, my_module:process(input))\n    ].\n\n%% Setup/cleanup\nwith_setup_test_() ->\n    {setup,\n     fun() -> setup() end,       % Setup\n     fun(X) -> cleanup(X) end,   % Cleanup\n     fun(Context) ->             % Tests\n         [\n             ?_test(test_with_context(Context))\n         ]\n     end\n    }.\n```\n\n### Common Test\n```erlang\n-module(my_SUITE).\n-compile(export_all).\n-include_lib(\"common_test/include/ct.hrl\").\n\nall() -> [test_case_1, test_case_2].\n\ninit_per_suite(Config) ->\n    %% Suite-wide setup\n    Config.\n\nend_per_suite(_Config) ->\n    ok.\n\ninit_per_testcase(_TestCase, Config) ->\n    Config.\n\nend_per_testcase(_TestCase, _Config) ->\n    ok.\n\ntest_case_1(_Config) ->\n    {ok, Result} = my_module:function(),\n    Expected = expected_value,\n    Expected = Result.\n```\n\n### Test Best Practices\n1. Test error cases, not just happy path\n2. Use ?assertMatch for complex patterns\n3. Name tests descriptively\n4. Keep tests isolated\n5. Mock external dependencies\n6. Run tests before committing: `rebar3 eunit`",
        "category": "testing-strategies",
        "language": "erlang",
        "priority": 95,
        "tags": [
            "testing",
            "eunit",
            "common-test"
        ]
    },
    {
        "title": "Logging Best Practices",
        "content": "## Logging in Erlang/OTP\n\n### Use Logger Module (OTP 21+)\n```erlang\n%% Import logger\n-include_lib(\"kernel/include/logger.hrl\").\n\n%% Log levels\n?LOG_DEBUG(\"Debug message: ~p\", [Data]),\n?LOG_INFO(\"Info message: ~p\", [Info]),\n?LOG_NOTICE(\"Notice: ~p\", [Notice]),\n?LOG_WARNING(\"Warning: ~p\", [Warning]),\n?LOG_ERROR(\"Error: ~p\", [Error]),\n?LOG_CRITICAL(\"Critical: ~p\", [Critical])\n```\n\n### Structured Logging\n```erlang\n?LOG_INFO(#{what => user_login,\n            user_id => UserId,\n            ip => IP,\n            result => success})\n```\n\n### Best Practices\n1. **Use appropriate log levels**\n   - DEBUG: Development/troubleshooting\n   - INFO: Important business events\n   - WARNING: Something unexpected but handled\n   - ERROR: Errors that need attention\n   - CRITICAL: System-critical failures\n\n2. **Include context**\n   ```erlang\n   ?LOG_ERROR(\"Failed to process order\",\n              #{order_id => OrderId,\n                user_id => UserId,\n                error => Reason,\n                stacktrace => Stacktrace})\n   ```\n\n3. **Don't log sensitive data**\n   - No passwords, tokens, or PII in logs\n   - Sanitize before logging\n\n4. **Use metadata**\n   ```erlang\n   logger:set_process_metadata(#{request_id => RequestId})\n   ```",
        "category": "coding-patterns",
        "language": "erlang",
        "priority": 90,
        "tags": [
            "logging",
            "observability"
        ]
    },
    {
        "title": "Maps vs Records",
        "content": "## When to Use Maps vs Records in Erlang\n\n### Use Records For:\n1. **Internal state in gen_servers**\n   ```erlang\n   -record(state, {\n       counter = 0 :: integer(),\n       data = [] :: list()\n   }).\n   ```\n\n2. **Well-defined data structures**\n   ```erlang\n   -record(user, {\n       id :: integer(),\n       username :: binary(),\n       email :: binary()\n   }).\n   ```\n\n3. **Performance-critical code** (records are tuples underneath)\n\n### Use Maps For:\n1. **API boundaries / External interfaces**\n   ```erlang\n   #{id => 1, username => <<\"john\">>, email => <<\"john@example.com\">>}\n   ```\n\n2. **Dynamic/flexible data**\n   ```erlang\n   Config = #{timeout => 5000, retries => 3, custom_field => value}\n   ```\n\n3. **JSON serialization**\n   ```erlang\n   jsx:encode(#{key => value})  % Easy conversion\n   ```\n\n### Pattern Matching\n```erlang\n%% Records\nprocess_user(#user{id = Id, username = Username}) ->\n    {Id, Username}.\n\n%% Maps\nprocess_user(#{id := Id, username := Username}) ->  % := for required keys\n    {Id, Username};\nprocess_user(#{id := Id} = User) ->  % => for optional keys\n    Username = maps:get(username, User, <<\"unknown\">>),\n    {Id, Username}.\n```\n\n### Conversion\n```erlang\n%% Record to map\nrecord_to_map(#user{id = Id, username = Username, email = Email}) ->\n    #{id => Id, username => Username, email => Email}.\n\n%% Map to record\nmap_to_record(#{id := Id, username := Username, email := Email}) ->\n    #user{id = Id, username = Username, email = Email}.\n```",
        "category": "coding-patterns",
        "language": "erlang",
        "priority": 88,
        "tags": [
            "data-structures",
            "maps",
            "records"
        ]
    }
]