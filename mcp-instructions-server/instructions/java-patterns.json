[
    {
        "title": "Spring Boot REST Controller Pattern",
        "content": "## Spring Boot REST Controller Best Practices\n\n### Basic Controller Structure\n```java\n@RestController\n@RequestMapping(\"/api/v1/users\")\n@RequiredArgsConstructor\n@Slf4j\npublic class UserController {\n    private final UserService userService;\n\n    @GetMapping(\"/{id}\")\n    public ResponseEntity<UserDto> getUser(@PathVariable Long id) {\n        log.debug(\"Fetching user with id: {}\", id);\n        return userService.findById(id)\n            .map(ResponseEntity::ok)\n            .orElse(ResponseEntity.notFound().build());\n    }\n\n    @PostMapping\n    @ResponseStatus(HttpStatus.CREATED)\n    public UserDto createUser(@Valid @RequestBody CreateUserRequest request) {\n        log.info(\"Creating user: {}\", request.getUsername());\n        return userService.create(request);\n    }\n\n    @PutMapping(\"/{id}\")\n    public ResponseEntity<UserDto> updateUser(\n            @PathVariable Long id,\n            @Valid @RequestBody UpdateUserRequest request) {\n        return userService.update(id, request)\n            .map(ResponseEntity::ok)\n            .orElse(ResponseEntity.notFound().build());\n    }\n\n    @DeleteMapping(\"/{id}\")\n    @ResponseStatus(HttpStatus.NO_CONTENT)\n    public void deleteUser(@PathVariable Long id) {\n        userService.delete(id);\n    }\n}\n```\n\n### Exception Handling\n```java\n@RestControllerAdvice\npublic class GlobalExceptionHandler {\n\n    @ExceptionHandler(EntityNotFoundException.class)\n    public ResponseEntity<ErrorResponse> handleNotFound(EntityNotFoundException ex) {\n        return ResponseEntity\n            .status(HttpStatus.NOT_FOUND)\n            .body(new ErrorResponse(ex.getMessage()));\n    }\n\n    @ExceptionHandler(MethodArgumentNotValidException.class)\n    public ResponseEntity<ErrorResponse> handleValidation(MethodArgumentNotValidException ex) {\n        Map<String, String> errors = ex.getBindingResult()\n            .getFieldErrors()\n            .stream()\n            .collect(Collectors.toMap(\n                FieldError::getField,\n                FieldError::getDefaultMessage\n            ));\n        return ResponseEntity\n            .status(HttpStatus.BAD_REQUEST)\n            .body(new ErrorResponse(\"Validation failed\", errors));\n    }\n}\n```\n\n### Best Practices\n1. Use `@RequiredArgsConstructor` for dependency injection\n2. Return `ResponseEntity<T>` for flexible status codes\n3. Use `@Valid` for request validation\n4. Use `@Slf4j` for logging\n5. Keep controllers thin - delegate to services\n6. Use DTOs for request/response, not entities",
        "category": "coding-patterns",
        "language": "java",
        "priority": 100,
        "tags": [
            "spring-boot",
            "rest",
            "controller",
            "api"
        ]
    },
    {
        "title": "Service Layer Pattern",
        "content": "## Spring Boot Service Layer\n\n### Service Structure\n```java\n@Service\n@RequiredArgsConstructor\n@Slf4j\n@Transactional(readOnly = true)\npublic class UserService {\n    private final UserRepository userRepository;\n    private final UserMapper userMapper;\n\n    public Optional<UserDto> findById(Long id) {\n        log.debug(\"Finding user by id: {}\", id);\n        return userRepository.findById(id)\n            .map(userMapper::toDto);\n    }\n\n    public List<UserDto> findAll() {\n        return userRepository.findAll().stream()\n            .map(userMapper::toDto)\n            .collect(Collectors.toList());\n    }\n\n    @Transactional\n    public UserDto create(CreateUserRequest request) {\n        log.info(\"Creating user: {}\", request.getUsername());\n        \n        if (userRepository.existsByUsername(request.getUsername())) {\n            throw new DuplicateUserException(\"Username already exists\");\n        }\n\n        User user = userMapper.toEntity(request);\n        User savedUser = userRepository.save(user);\n        \n        log.info(\"User created with id: {}\", savedUser.getId());\n        return userMapper.toDto(savedUser);\n    }\n\n    @Transactional\n    public Optional<UserDto> update(Long id, UpdateUserRequest request) {\n        return userRepository.findById(id)\n            .map(user -> {\n                userMapper.updateEntity(request, user);\n                return userRepository.save(user);\n            })\n            .map(userMapper::toDto);\n    }\n\n    @Transactional\n    public void delete(Long id) {\n        if (!userRepository.existsById(id)) {\n            throw new EntityNotFoundException(\"User not found\");\n        }\n        userRepository.deleteById(id);\n    }\n}\n```\n\n### Best Practices\n1. Default to `@Transactional(readOnly = true)` on class\n2. Add `@Transactional` on write methods\n3. Return `Optional<T>` for single entities\n4. Validate business rules in service layer\n5. Use mappers for entity <-> DTO conversion\n6. Log important business operations",
        "category": "coding-patterns",
        "language": "java",
        "priority": 99,
        "tags": [
            "spring-boot",
            "service",
            "transaction"
        ]
    },
    {
        "title": "JPA Entity Best Practices",
        "content": "## JPA Entity Design\n\n### Entity Structure\n```java\n@Entity\n@Table(name = \"users\", indexes = {\n    @Index(name = \"idx_username\", columnList = \"username\"),\n    @Index(name = \"idx_email\", columnList = \"email\")\n})\n@Getter\n@Setter\n@NoArgsConstructor\n@AllArgsConstructor\n@Builder\npublic class User {\n\n    @Id\n    @GeneratedValue(strategy = GenerationType.IDENTITY)\n    private Long id;\n\n    @Column(nullable = false, unique = true, length = 50)\n    private String username;\n\n    @Column(nullable = false, unique = true)\n    private String email;\n\n    @Column(nullable = false)\n    private String password;\n\n    @Enumerated(EnumType.STRING)\n    @Column(nullable = false)\n    private UserStatus status = UserStatus.ACTIVE;\n\n    @CreatedDate\n    @Column(nullable = false, updatable = false)\n    private LocalDateTime createdAt;\n\n    @LastModifiedDate\n    @Column(nullable = false)\n    private LocalDateTime updatedAt;\n\n    @Version\n    private Long version; // Optimistic locking\n\n    @Override\n    public boolean equals(Object o) {\n        if (this == o) return true;\n        if (!(o instanceof User)) return false;\n        User user = (User) o;\n        return id != null && id.equals(user.getId());\n    }\n\n    @Override\n    public int hashCode() {\n        return getClass().hashCode();\n    }\n}\n```\n\n### Relationship Mapping\n```java\n// One-to-Many\n@OneToMany(mappedBy = \"user\", cascade = CascadeType.ALL, orphanRemoval = true)\nprivate List<Order> orders = new ArrayList<>();\n\n// Helper methods for bidirectional relationship\npublic void addOrder(Order order) {\n    orders.add(order);\n    order.setUser(this);\n}\n\npublic void removeOrder(Order order) {\n    orders.remove(order);\n    order.setUser(null);\n}\n\n// Many-to-One\n@ManyToOne(fetch = FetchType.LAZY)\n@JoinColumn(name = \"user_id\", nullable = false)\nprivate User user;\n```\n\n### Best Practices\n1. Always override `equals()` and `hashCode()` using ID\n2. Use `@Table` to define indexes\n3. Set proper `nullable` and `unique` constraints\n4. Use `@Version` for optimistic locking\n5. Default to `FetchType.LAZY` for relationships\n6. Use helper methods for bidirectional relationships\n7. Don't use Lombok's `@Data` or `@EqualsAndHashCode` on entities",
        "category": "coding-patterns",
        "language": "java",
        "priority": 98,
        "tags": [
            "jpa",
            "entity",
            "database",
            "hibernate"
        ]
    },
    {
        "title": "Repository Pattern",
        "content": "## Spring Data JPA Repository\n\n### Basic Repository\n```java\n@Repository\npublic interface UserRepository extends JpaRepository<User, Long> {\n    \n    Optional<User> findByUsername(String username);\n    \n    Optional<User> findByEmail(String email);\n    \n    boolean existsByUsername(String username);\n    \n    List<User> findByStatus(UserStatus status);\n    \n    @Query(\"SELECT u FROM User u WHERE u.createdAt > :date\")\n    List<User> findRecentUsers(@Param(\"date\") LocalDateTime date);\n    \n    @Query(value = \"SELECT * FROM users WHERE status = ?1 ORDER BY created_at DESC\",\n           nativeQuery = true)\n    List<User> findByStatusNative(String status);\n}\n```\n\n### Custom Repository Implementation\n```java\npublic interface UserRepositoryCustom {\n    List<User> searchUsers(UserSearchCriteria criteria);\n}\n\n@RequiredArgsConstructor\npublic class UserRepositoryCustomImpl implements UserRepositoryCustom {\n    private final EntityManager entityManager;\n\n    @Override\n    public List<User> searchUsers(UserSearchCriteria criteria) {\n        CriteriaBuilder cb = entityManager.getCriteriaBuilder();\n        CriteriaQuery<User> query = cb.createQuery(User.class);\n        Root<User> user = query.from(User.class);\n        \n        List<Predicate> predicates = new ArrayList<>();\n        \n        if (criteria.getUsername() != null) {\n            predicates.add(cb.like(user.get(\"username\"), \n                                   \"%\" + criteria.getUsername() + \"%\"));\n        }\n        \n        if (criteria.getStatus() != null) {\n            predicates.add(cb.equal(user.get(\"status\"), criteria.getStatus()));\n        }\n        \n        query.where(predicates.toArray(new Predicate[0]));\n        \n        return entityManager.createQuery(query).getResultList();\n    }\n}\n\npublic interface UserRepository extends JpaRepository<User, Long>, UserRepositoryCustom {\n    // Combined interface\n}\n```\n\n### Best Practices\n1. Use query methods for simple queries\n2. Use `@Query` for complex JPQL queries\n3. Use Criteria API for dynamic queries\n4. Avoid N+1 queries - use `@EntityGraph` or JOIN FETCH\n5. Use projections for read-only queries\n6. Don't return entities from REST controllers",
        "category": "coding-patterns",
        "language": "java",
        "priority": 97,
        "tags": [
            "spring-data",
            "jpa",
            "repository"
        ]
    },
    {
        "title": "DTO and Mapper Pattern",
        "content": "## DTO and Mapper Best Practices\n\n### DTOs\n```java\n// Response DTO\n@Data\n@Builder\npublic class UserDto {\n    private Long id;\n    private String username;\n    private String email;\n    private UserStatus status;\n    private LocalDateTime createdAt;\n}\n\n// Request DTO\n@Data\npublic class CreateUserRequest {\n    @NotBlank(message = \"Username is required\")\n    @Size(min = 3, max = 50, message = \"Username must be between 3 and 50 characters\")\n    private String username;\n\n    @NotBlank(message = \"Email is required\")\n    @Email(message = \"Invalid email format\")\n    private String email;\n\n    @NotBlank(message = \"Password is required\")\n    @Size(min = 8, message = \"Password must be at least 8 characters\")\n    private String password;\n}\n\n@Data\npublic class UpdateUserRequest {\n    @Size(min = 3, max = 50)\n    private String username;\n\n    @Email\n    private String email;\n}\n```\n\n### MapStruct Mapper\n```java\n@Mapper(componentModel = \"spring\")\npublic interface UserMapper {\n\n    UserDto toDto(User entity);\n\n    List<UserDto> toDtoList(List<User> entities);\n\n    @Mapping(target = \"id\", ignore = true)\n    @Mapping(target = \"createdAt\", ignore = true)\n    @Mapping(target = \"updatedAt\", ignore = true)\n    @Mapping(target = \"version\", ignore = true)\n    User toEntity(CreateUserRequest request);\n\n    @Mapping(target = \"id\", ignore = true)\n    @Mapping(target = \"createdAt\", ignore = true)\n    @Mapping(target = \"updatedAt\", ignore = true)\n    @Mapping(target = \"version\", ignore = true)\n    void updateEntity(UpdateUserRequest request, @MappingTarget User entity);\n}\n```\n\n### Manual Mapper (if not using MapStruct)\n```java\n@Component\npublic class UserMapper {\n\n    public UserDto toDto(User entity) {\n        return UserDto.builder()\n            .id(entity.getId())\n            .username(entity.getUsername())\n            .email(entity.getEmail())\n            .status(entity.getStatus())\n            .createdAt(entity.getCreatedAt())\n            .build();\n    }\n\n    public User toEntity(CreateUserRequest request) {\n        return User.builder()\n            .username(request.getUsername())\n            .email(request.getEmail())\n            .password(request.getPassword())\n            .status(UserStatus.ACTIVE)\n            .build();\n    }\n}\n```\n\n### Best Practices\n1. Never expose entities in REST APIs\n2. Use separate DTOs for create/update/response\n3. Add validation annotations on request DTOs\n4. Use MapStruct for automatic mapping\n5. Exclude sensitive fields (e.g., password) from response DTOs\n6. Use `@JsonIgnore` or `@JsonProperty` for JSON customization",
        "category": "coding-patterns",
        "language": "java",
        "priority": 96,
        "tags": [
            "dto",
            "mapper",
            "mapstruct",
            "validation"
        ]
    },
    {
        "title": "Testing Patterns",
        "content": "## Java Testing Best Practices\n\n### Unit Tests\n```java\n@ExtendWith(MockitoExtension.class)\nclass UserServiceTest {\n\n    @Mock\n    private UserRepository userRepository;\n\n    @Mock\n    private UserMapper userMapper;\n\n    @InjectMocks\n    private UserService userService;\n\n    @Test\n    @DisplayName(\"Should find user by id\")\n    void shouldFindUserById() {\n        // Given\n        Long userId = 1L;\n        User user = User.builder().id(userId).username(\"john\").build();\n        UserDto expectedDto = UserDto.builder().id(userId).username(\"john\").build();\n        \n        when(userRepository.findById(userId)).thenReturn(Optional.of(user));\n        when(userMapper.toDto(user)).thenReturn(expectedDto);\n\n        // When\n        Optional<UserDto> result = userService.findById(userId);\n\n        // Then\n        assertThat(result).isPresent();\n        assertThat(result.get().getUsername()).isEqualTo(\"john\");\n        verify(userRepository).findById(userId);\n    }\n\n    @Test\n    @DisplayName(\"Should throw exception when creating duplicate user\")\n    void shouldThrowExceptionForDuplicateUser() {\n        // Given\n        CreateUserRequest request = new CreateUserRequest();\n        request.setUsername(\"john\");\n        \n        when(userRepository.existsByUsername(\"john\")).thenReturn(true);\n\n        // When / Then\n        assertThatThrownBy(() -> userService.create(request))\n            .isInstanceOf(DuplicateUserException.class)\n            .hasMessage(\"Username already exists\");\n    }\n}\n```\n\n### Integration Tests\n```java\n@SpringBootTest\n@AutoConfigureMockMvc\n@Transactional\nclass UserControllerIntegrationTest {\n\n    @Autowired\n    private MockMvc mockMvc;\n\n    @Autowired\n    private ObjectMapper objectMapper;\n\n    @Test\n    @DisplayName(\"Should create user\")\n    void shouldCreateUser() throws Exception {\n        CreateUserRequest request = new CreateUserRequest();\n        request.setUsername(\"john\");\n        request.setEmail(\"john@example.com\");\n        request.setPassword(\"password123\");\n\n        mockMvc.perform(post(\"/api/v1/users\")\n                .contentType(MediaType.APPLICATION_JSON)\n                .content(objectMapper.writeValueAsString(request)))\n            .andExpect(status().isCreated())\n            .andExpect(jsonPath(\"$.username\").value(\"john\"))\n            .andExpect(jsonPath(\"$.email\").value(\"john@example.com\"));\n    }\n\n    @Test\n    @DisplayName(\"Should return 400 for invalid request\")\n    void shouldReturnBadRequestForInvalidData() throws Exception {\n        CreateUserRequest request = new CreateUserRequest();\n        request.setUsername(\"a\"); // Too short\n\n        mockMvc.perform(post(\"/api/v1/users\")\n                .contentType(MediaType.APPLICATION_JSON)\n                .content(objectMapper.writeValueAsString(request)))\n            .andExpect(status().isBadRequest());\n    }\n}\n```\n\n### Repository Tests\n```java\n@DataJpaTest\nclass UserRepositoryTest {\n\n    @Autowired\n    private UserRepository userRepository;\n\n    @Autowired\n    private TestEntityManager entityManager;\n\n    @Test\n    @DisplayName(\"Should find user by username\")\n    void shouldFindByUsername() {\n        // Given\n        User user = User.builder()\n            .username(\"john\")\n            .email(\"john@example.com\")\n            .password(\"password\")\n            .build();\n        entityManager.persist(user);\n        entityManager.flush();\n\n        // When\n        Optional<User> found = userRepository.findByUsername(\"john\");\n\n        // Then\n        assertThat(found).isPresent();\n        assertThat(found.get().getEmail()).isEqualTo(\"john@example.com\");\n    }\n}\n```\n\n### Best Practices\n1. Use `@ExtendWith(MockitoExtension.class)` for unit tests\n2. Use `@DataJpaTest` for repository tests\n3. Use `@SpringBootTest` for integration tests\n4. Follow AAA pattern: Arrange, Act, Assert\n5. Use descriptive test method names\n6. Use AssertJ for fluent assertions\n7. Test both happy path and error cases",
        "category": "testing-strategies",
        "language": "java",
        "priority": 95,
        "tags": [
            "testing",
            "junit",
            "mockito",
            "integration-tests"
        ]
    },
    {
        "title": "Configuration Management",
        "content": "## Spring Boot Configuration\n\n### application.yml Structure\n```yaml\nspring:\n  application:\n    name: user-service\n  \n  datasource:\n    url: jdbc:postgresql://localhost:5432/mydb\n    username: ${DB_USERNAME:postgres}\n    password: ${DB_PASSWORD:postgres}\n    hikari:\n      maximum-pool-size: 10\n      minimum-idle: 5\n      connection-timeout: 30000\n  \n  jpa:\n    hibernate:\n      ddl-auto: validate\n    show-sql: false\n    properties:\n      hibernate:\n        dialect: org.hibernate.dialect.PostgreSQLDialect\n        format_sql: true\n        jdbc:\n          batch_size: 20\n  \n  flyway:\n    enabled: true\n    locations: classpath:db/migration\n    baseline-on-migrate: true\n\nlogging:\n  level:\n    root: INFO\n    com.example: DEBUG\n  pattern:\n    console: \"%d{yyyy-MM-dd HH:mm:ss} - %msg%n\"\n\nserver:\n  port: 8080\n  error:\n    include-message: always\n    include-stacktrace: never\n```\n\n### Configuration Properties\n```java\n@Configuration\n@ConfigurationProperties(prefix = \"app\")\n@Data\npublic class AppProperties {\n    private Security security = new Security();\n    private Cache cache = new Cache();\n\n    @Data\n    public static class Security {\n        private String jwtSecret;\n        private long jwtExpirationMs;\n    }\n\n    @Data\n    public static class Cache {\n        private int ttl = 3600;\n        private int maxSize = 1000;\n    }\n}\n```\n\n### Profile-Specific Configuration\n```yaml\n# application-dev.yml\nspring:\n  jpa:\n    show-sql: true\n    hibernate:\n      ddl-auto: create-drop\n\nlogging:\n  level:\n    com.example: DEBUG\n\n# application-prod.yml\nspring:\n  jpa:\n    show-sql: false\n    hibernate:\n      ddl-auto: validate\n\nlogging:\n  level:\n    com.example: INFO\n```\n\n### Best Practices\n1. Use environment variables for sensitive data\n2. Provide default values: `${VAR:default}`\n3. Use profiles for environment-specific config\n4. Use `@ConfigurationProperties` for type-safe config\n5. Never commit secrets to git\n6. Use Flyway or Liquibase for migrations\n7. Set `ddl-auto: validate` in production",
        "category": "project-configs",
        "language": "java",
        "priority": 94,
        "tags": [
            "configuration",
            "spring-boot",
            "properties"
        ]
    }
]