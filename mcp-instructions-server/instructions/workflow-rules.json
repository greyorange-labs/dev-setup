[
    {
        "title": "Phase 1: Requirement Clarification",
        "content": "## Requirement Clarification\n\nBefore implementing any change, you MUST:\n\n1. **Restate the Requirement**\n   - Paraphrase the requirement in your own words\n   - Ask the user to confirm your understanding\n   - Example: \"Let me confirm: You want to add a new API endpoint that...\"\n\n2. **Identify Scope**\n   - Which applications/modules will be affected?\n   - Which components need changes?\n   - What dependencies exist?\n   - List files that might need modification\n\n3. **Note Assumptions**\n   - Explicitly state any assumptions you're making\n   - Identify missing information\n   - Ask clarifying questions\n\n4. **Request Verification**\n   - Wait for user confirmation before proceeding to planning\n   - Don't skip this step even if the requirement seems clear\n\n**Output Format:**\n```\n### Requirement Analysis\n- **What I Understand**: [Your interpretation]\n- **Affected Components**: [List of modules/apps]\n- **Assumptions**: [List your assumptions]\n- **Questions**: [Any clarifications needed]\n\n**Please confirm before I proceed to planning.**\n```",
        "category": "workflow-rules",
        "priority": 100,
        "tags": [
            "phase-1",
            "clarification",
            "verification"
        ]
    },
    {
        "title": "Phase 2: Planning",
        "content": "## Planning Phase\n\nOnce requirements are confirmed, create a detailed plan:\n\n1. **Gather Context**\n   - Read relevant code files\n   - Check existing patterns in the codebase\n   - Review component-specific guidelines\n   - Look for similar implementations\n\n2. **Check Instructions**\n   - Query MCP server for language-specific patterns\n   - Review project configuration\n   - Check for common pitfalls\n   - Review testing strategies\n\n3. **Create Implementation Plan**\n   - List all files that need to be created/modified\n   - Specify the order of changes\n   - Identify dependencies between changes\n   - Note any breaking changes\n\n4. **Define Testing Strategy**\n   - What tests need to be written?\n   - What existing tests need updates?\n   - How will you validate the changes?\n   - What manual testing is needed?\n\n5. **Identify Risks**\n   - What could go wrong?\n   - What edge cases need consideration?\n   - What backward compatibility issues exist?\n   - What performance impacts might occur?\n\n**Output Format:**\n```\n### Implementation Plan\n\n**Files to Modify:**\n1. [file path] - [what changes]\n2. [file path] - [what changes]\n\n**Files to Create:**\n1. [file path] - [purpose]\n\n**Order of Implementation:**\n1. [step with rationale]\n2. [step with rationale]\n\n**Testing Strategy:**\n- Unit tests: [list]\n- Integration tests: [list]\n- Manual verification: [list]\n\n**Risks & Mitigations:**\n- Risk: [description] → Mitigation: [approach]\n\n**Please review and approve before I start implementation.**\n```",
        "category": "workflow-rules",
        "priority": 99,
        "tags": [
            "phase-2",
            "planning",
            "testing"
        ]
    },
    {
        "title": "Phase 3: Implementation",
        "content": "## Implementation Phase\n\nExecute the approved plan with continuous validation:\n\n1. **Follow the Plan**\n   - Implement changes in the agreed order\n   - Don't skip steps or take shortcuts\n   - Stay within the agreed scope\n\n2. **Apply Language/Framework Patterns**\n   - Use project-specific coding standards\n   - Follow established patterns in the codebase\n   - Avoid anti-patterns and common pitfalls\n\n3. **Validate Continuously**\n   - Run formatters after each file change\n   - Run type checkers (dialyzer for Erlang, TypeScript compiler, etc.)\n   - Run unit tests as you implement\n   - Fix errors immediately before proceeding\n\n4. **Document as You Go**\n   - Add/update inline comments for complex logic\n   - Update function documentation\n   - Note any deviations from the plan\n\n5. **Handle Issues**\n   - If you encounter blockers, stop and report\n   - Don't guess or work around issues silently\n   - Ask for guidance if plan needs adjustment\n\n**Validation Commands:**\n- Format: `make format` or language-specific formatter\n- Type check: `make dialyzer` (Erlang), `tsc --noEmit` (TypeScript)\n- Tests: `make test` or test runner\n- Lint: `make lint` or linter command",
        "category": "workflow-rules",
        "priority": 98,
        "tags": [
            "phase-3",
            "implementation",
            "validation"
        ]
    },
    {
        "title": "Phase 4: Review and Summary",
        "content": "## Review Phase\n\nAfter implementation, provide comprehensive review:\n\n1. **Summarize Changes**\n   - List all modified files\n   - Describe what changed in each\n   - Highlight any deviations from plan\n\n2. **Validation Results**\n   - Report format check results\n   - Report type checker results\n   - Report test results\n   - Note any remaining warnings\n\n3. **Testing Evidence**\n   - Show test output\n   - Provide manual testing steps performed\n   - Note any edge cases tested\n\n4. **Next Steps**\n   - What manual verification is recommended?\n   - What integration testing is needed?\n   - What documentation needs updates?\n   - What follow-up tasks exist?\n\n5. **Known Issues**\n   - List any limitations\n   - Note any technical debt introduced\n   - Mention any follow-up improvements\n\n**Output Format:**\n```\n### Implementation Summary\n\n**Files Changed:**\n- [file]: [description of changes]\n\n**Validation Results:**\n✅ Format check: Passed\n✅ Type check: Passed\n✅ Unit tests: 15/15 passed\n⚠️  Integration tests: Skipped (manual verification needed)\n\n**Next Steps:**\n1. [verification step]\n2. [documentation update]\n3. [deployment consideration]\n\n**Known Limitations:**\n- [limitation with rationale]\n```",
        "category": "workflow-rules",
        "priority": 97,
        "tags": [
            "phase-4",
            "review",
            "summary"
        ]
    },
    {
        "title": "Context Gathering Protocol",
        "content": "## Always Gather Context First\n\nNEVER make changes without understanding the codebase:\n\n1. **Read Before Writing**\n   - Read existing implementations of similar features\n   - Understand the current architecture\n   - Check for existing helper functions/modules\n   - Review recent changes to related code\n\n2. **Check Documentation**\n   - Look for README files\n   - Check .github/copilot-instructions.md\n   - Review component-specific guidelines\n   - Read inline comments in relevant files\n\n3. **Query MCP Resources**\n   - `instructions://coding-patterns/{language}` - Language patterns\n   - `instructions://project-config/{project}` - Project rules\n   - `instructions://pitfalls/{language}` - Common mistakes\n   - `instructions://context-aware` - Auto-detected context\n\n4. **Understand Dependencies**\n   - What modules/libraries are used?\n   - What are the version constraints?\n   - Are there deprecated APIs to avoid?\n   - What breaking changes have occurred?\n\n**Example Questions to Answer:**\n- How is error handling done in this project?\n- What naming conventions are used?\n- How are tests structured?\n- What logging framework is used?\n- How is configuration managed?",
        "category": "workflow-rules",
        "priority": 95,
        "tags": [
            "context",
            "research",
            "preparation"
        ]
    },
    {
        "title": "Error Prevention Checklist",
        "content": "## Zero-Error Implementation Checklist\n\nBefore marking implementation complete:\n\n### Code Quality\n- [ ] No syntax errors\n- [ ] No type errors (dialyzer/TypeScript/etc.)\n- [ ] No linter warnings (unless justified)\n- [ ] Consistent formatting\n- [ ] Proper indentation\n\n### Correctness\n- [ ] All error cases handled\n- [ ] Edge cases considered\n- [ ] Null/undefined checks where needed\n- [ ] Proper validation of inputs\n- [ ] Correct error types returned\n\n### Testing\n- [ ] Unit tests written and passing\n- [ ] Test coverage is adequate\n- [ ] Integration tests updated if needed\n- [ ] Manual testing performed\n\n### Documentation\n- [ ] Function/module documentation complete\n- [ ] Complex logic explained in comments\n- [ ] Type specifications accurate\n- [ ] Examples provided where helpful\n\n### Compatibility\n- [ ] Backward compatible (or breaking changes noted)\n- [ ] No deprecated APIs used\n- [ ] Dependencies correctly specified\n- [ ] Version constraints satisfied\n\n### Performance\n- [ ] No obvious performance issues\n- [ ] Database queries optimized\n- [ ] No N+1 query problems\n- [ ] Resource cleanup handled (close files/connections)\n\n### Security\n- [ ] Input sanitized\n- [ ] No SQL injection vulnerabilities\n- [ ] No hardcoded secrets\n- [ ] Proper access control checks",
        "category": "workflow-rules",
        "priority": 90,
        "tags": [
            "checklist",
            "validation",
            "quality"
        ]
    },
    {
        "title": "Documentation Approval Required",
        "content": "## CRITICAL: Always Ask Before Creating Documentation\n\n**NEVER create any documentation files without explicit user approval.**\n\nThis applies to:\n- README files\n- Architecture documentation\n- API documentation\n- Design documents\n- How-to guides\n- Migration guides\n- Any markdown (.md) files\n- Comments exceeding 10 lines\n- Wiki pages\n- Confluence pages\n\n### Rules:\n\n1. **Always Ask First**\n   ```\n   \"Should I create documentation for this feature?\"\n   \"Do you want me to add a README for this module?\"\n   \"Would you like documentation for this API?\"\n   ```\n\n2. **Wait for Explicit Approval**\n   - Don't assume documentation is needed\n   - Don't create docs \"just in case\"\n   - User must explicitly say \"yes\" or \"create it\"\n\n3. **Ask About Scope**\n   If user approves documentation:\n   ```\n   \"What should the documentation cover?\"\n   \"What level of detail do you want?\"\n   \"Who is the target audience?\"\n   ```\n\n4. **Exceptions (Still Add Value)**\n   You MAY add without asking:\n   - Inline code comments (< 10 lines)\n   - Function/method docstrings\n   - Type annotations\n   - Brief commit messages\n\n### Example Interactions:\n\n**❌ WRONG:**\n```\nUser: \"Add a user authentication module\"\nCopilot: [Creates code + README.md without asking]\n```\n\n**✅ CORRECT:**\n```\nUser: \"Add a user authentication module\"\nCopilot: \"I'll implement the authentication module. \nShould I also create documentation for it?\"\nUser: \"No, just the code\"\nCopilot: [Creates only code]\n```\n\n**✅ CORRECT:**\n```\nUser: \"Add a user authentication module\"\nCopilot: \"Should I create documentation?\"\nUser: \"Yes, create a README\"\nCopilot: \"What should it cover? Usage examples, \narchitecture, API reference, or all three?\"\nUser: \"Just usage examples\"\nCopilot: [Creates code + README with usage examples only]\n```\n\n### Enforcement:\n\n- This rule has **HIGHEST PRIORITY**\n- Applies to ALL workspaces and projects\n- No exceptions unless user explicitly requests docs\n- If in doubt, ASK\n\n### Why This Matters:\n\n- User may have existing documentation standards\n- Documentation may be managed elsewhere (Confluence, Wiki)\n- User may not want documentation at all\n- User decides what's documented, not the AI\n\n**Remember: Code is required. Documentation is optional and requires permission.**",
        "category": "workflow-rules",
        "priority": 100,
        "tags": [
            "documentation",
            "approval",
            "critical",
            "permissions"
        ]
    }
]